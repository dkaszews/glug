# Important: This workflow ensures every other one runs,
# so please make sure it still runs after you modify it!
name: Pull
on:
  pull_request:

jobs:
  actionlint:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4
      - uses: raven-actions/actionlint@v2

  issue:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            core.debug(JSON.stringify(context));
            const pr = context.payload.pull_request;

            let match = null;
            const re = /\b(?:close|fixe?|resolve)[sd]?:? #(?<issue>\d+)/;
            while ((match = re.exec(pr.body.toLowerCase())) !== null) {
                const issue_number = match.groups['issue'];
                const issue = await github.rest.issues.get(
                    { ...context.repo, issue_number, per_page: 100 }
                );

                const is_bug = issue.labels.any(l => l.name == 'bug');
                const issue_title = `${is_bug ? 'Fix ' : ''}${issue.title}`;
                core.info(`Issue #${issue_number} wants title: ${issue_title}`);

                if (issue_title !== pr.title) {
                    core.info('Match');
                    return;
                }
            }
            core.setFailed(`No linked issues matching PR title: ${pr.title}`);

  required:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    permissions: { actions: read }
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            core.info('failed/completed/total:');
            while (true) {
                const ref = context.payload.pull_request.head.ref;
                const jobs = await github.paginate(
                    github.rest.checks.listForRef,
                    { ...context.repo, ref, per_page: 100 }
                );
                const others = jobs.filter(j => j.name !== context.job);
                const completed = others.filter(j => j.status === 'completed');
                const failed = completed.filter(j => j.conclusion[0] !== 's');

                core.info(`${failed.length}/${completed.length}/${others.length}`)
                if (failed.length) {
                    core.setFailed(`Failed: ${failed.map(j => j.name).join(', ')}`);
                    break;
                } else if (completed.length == others.length) {
                    break;
                }
                await new Promise((r) => setTimeout(r, 10 * 1000));
            }

